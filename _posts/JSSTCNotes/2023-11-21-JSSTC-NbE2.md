---
layout: post
title:  "Review JS's STC's NbE2"
date:   2023-11-03 00:56:11 -0400
categories: Type-Theory Cat-Theory
---

We type-set JS's STC and its application on proving NbE of STLC

Ref:
(JS1) https://www.jonmsterling.com/papers/sterling-2022-naive.pdf

(JS2) https://www.cs.cmu.edu/~rwh/students/sterling.pdf

(JS3) https://arxiv.org/abs/1809.08646



***
A current big problem is we don't understand `var` in the JS'STC proof.

Let's look at the classical gluing to see if we can understand var in that sceanrio.

# Without HOAS



```haskell
record STLC where
  
  Hom : â–¡ â†’ â–¡ â†’ â–¡
  DHom : (a : â–¡) â†’ (a â†’ â–¡) â†’ â–¡
  // we omit the introduction and elim rule for Hom and DHom,
  // but apparently they are lambda intro

  // using this fake syntax, we can 

  ty : â–¡
  tm : ty â†’ â–¡
  â‡’  : ty â†’ ty â†’ ty 
  Î»  : (tm A â†’ tm B) â†’ tm (A â‡’ B)
  app : tm (A â‡’ B) â†’ (tm A â†’ tm B)
  Î»Î² : app (Î» f) â‰¡ f
  Î»Î· : Î» (app f) â‰¡ f
  //  observable for parametricity later
  ğ”¹ : ty 
  tt : tm ğ”¹
  ff : tm ğ”¹
  ifb : tm ğ”¹ â†’ tm T â†’ tm T â†’ tm T
  ifbÎ²â‚ : ifb tt x y â‰¡ x 
  ifbÎ²â‚ : ifb ff x y â‰¡ y 
```

Since 


```haskell

module Canoncity where 
tyá´¾ : Set
tyá´¾ = âˆ‘ (T : Hom(1, S.ty)), 
        âˆ‘ C : Hom (?, tm(T)) â†’ PSet // denotes normalizable
        âˆ‘ â‡‘ : (t : Ne ? T) â†’ C [t]
        âˆ‘ â‡“ : C [t] â†’ Nf ? T
// depenndet pair of a closed term, and an arrow in the presheaf category

tmá´¾ : tyá´¾ â†’ PSet
tmá´¾ T = âˆ‘ t : Hom(1, S.tm Tâ‚›), T.C t

â‡’  : ty â†’ ty â†’ ty 
â‡’ A B = (S.â‡’ Aâ‚› Bâ‚›, _)
(â‡’ A B).C : 
Î»  : (tm A â†’ tm B) â†’ tm (A â‡’ B)
app : tm (A â‡’ B) â†’ (tm A â†’ tm B)
Î»Î² : app (Î» f) â‰¡ f
Î»Î· : Î» (app f) â‰¡ f
//  observable for parametricity later
ğ”¹ : ty 
tt : tm ğ”¹
ff : tm ğ”¹

```

# Syntax

Syntax in STC is written in HOAS, as before

```agda 
record STLC : Set where 
  ty : â–¡
  tm : ty â†’ â–¡
  bool : ty 
  true :  tm bool
  false : tm bool
  arr : ty â†’ ty â†’ ty
  lam : (tm A â†’ tm B) â†’ tm (arr A B)
  app : tm (arr A B) â†’ tm A â†’ tm B
  lamÎ² : app (lam f) = f
  lamÎ· : lam (app f) = f 
```

Like STC for Canonicity, we write

