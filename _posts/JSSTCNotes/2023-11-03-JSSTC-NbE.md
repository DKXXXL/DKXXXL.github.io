---
layout: post
title:  "Review JS's STC's NbE'"
date:   2023-11-03 00:56:11 -0400
categories: Type-Theory Cat-Theory
---

We type-set JS's STC and its application on proving NbE of STLC

Ref:
(JS1) https://www.jonmsterling.com/papers/sterling-2022-naive.pdf

(JS2) https://www.cs.cmu.edu/~rwh/students/sterling.pdf

(JS3) https://arxiv.org/abs/1809.08646


# What is open term here?

æˆ‘ä¹‹å‰æœ‰ä¸ªå·¨å¤§çš„é”™è¯¯ç†è§£ -- æˆ‘ä»¥ä¸ºSterlingæŠŠtm = `âˆ‘ (A : tp), tm(A)` ä¹‹åï¼ŒNbEä¹Ÿæ˜¯åœ¨closed termä¸Šçš„ï¼ˆæ¯•ç«Ÿsyntaxé‡Œé¢éƒ½æ²¡æœ‰contextäº†ã€‚ã€‚ï¼‰ã€‚
ä½†å…¶å®ä»–åº”è¯¥æ˜¯åœ¨ç”¨
Î±(Î“) â†’ tm æ¥è¡¨è¾¾open termäº†ï¼Œç„¶åæ‰ä¼šæœ‰atomic & canonical pointï¼ˆæˆ‘è¯»äº†å¥½ä¹…éƒ½ä¸çŸ¥é“è¿™ä¸¤ä¸ªç©æ„æ˜¯å¹²å•¥ç”¨çš„ç¬‘æ­»ï¼‰


# General Proof Structure of Synthetic Normalization


This is a summary of proof structure in (JS2, Chapter 5)

1. Still we use the same syntax.

2. Then we glue a topos based on renaming/atomic category ğ´, and then do a glue (5.5.1âˆ—7) via the figure shape Î± : ğ´ â†’ ğ‘‡.


3. Then we explore the existence of `var(A)` (JS2,5.5.3âˆ—3) **The hardest! Have no idea**

4. Then we define normal, neutral form in the closed subspace of the glued topos (Section 5.4.1)

5. Finally we construct Synthetic Logical Relation 


## 5.5.3âˆ—3

åœ¨Presheaf Caté‡Œé¢ï¼Œæˆ‘èƒ½ä¸èƒ½å¦‚ä¸‹æ–¹å¼å®šä¹‰ä¸€ä¸ªrepresentable natural transformation?
æ ¹æ®


## 5.5.3âˆ—3, But Intensionally


Notice in Â§ 5.5, the ğ’œ category is exactly the category of renaming, so this section is a categorical reformulation of 
Coquand's normalization paper.

Sure, we need to construct `var : (X : tp) â†’ {ğ’° | Â¶ â†ª tm(X)}`
and thus we have 
`var(X) = [Â¶ â†ª x : tm(X) | ?]`

we definitely know `?` should be a proposition indicating `x` should be a pure variable. Inspect our toolset, we don't have enough tools to specify that internally. 

Let's jump out externally, but the first problem is, what is `x : tm(A)` externally speaking. In STLC we can say that is something like `Hom(1, tm(A))` but not in dependnet type. To make `tm(A)` a 
real object, we have to close the free variable `tm = âˆ‘ (A : tp) tm(A)`

Now we know the `var* : {ğ’° | Â¶ â†ª tm}` indicating all kinds of variables.
`var* = [ Â¶ â†ª x : tm | ? ]`

`?` should be a proof that `x` is a variable (of all kinds of types). 

Can we construct this proof internally?

***
However, 
Review Â§ 5.5,
we can construct `V : Pr(ğ’œ)`, where `V(Î“) = { (T, x) | T : Ty(Î“), x is variable of type T in Î“ }`. Intensionally, `V` should corresponds to `tm` directly, and we have `inj : V â†’ Î±*(y(tm))` (we will omit y later)

Then we consider the object `var* = (tm, V, inj â†’ Î±*(tm))`.
As most objects in Glued topos/Logical Relation are pairs, and have two components, one for syntax, the other for the meta-level reasoning. So this pair, directly read it,
intuitively, `x : (tm, V, inj : V â†’ Î±*(tm))` should give us a variable in `Pr(ğ’¯)` and its corresponding form in `x' : V : Pr(ğ’œ)`, where `inj` should be the proof that `inj x' = x`. 

We prove that:
1. Consider arbitrary `x : Hom(1, var*)`, it has two morphism 
`â—‹x : Hom_ğ’¯(1, tm)` and `âšˆx : Hom_ğ’œ(1, V)` and a commutative diagram. We should be able to read the commutative diagram as `inj âšˆx = â—‹x`. Now verify it!
2. Consider arbitrary `x : Hom(?, var*)` for arbitrary context `Î“ : ğ’œ`, it has two morphism 
`â—‹x : Hom_ğ’¯(?, tm)` and `âšˆx : Hom_ğ’œ(y(Î“), V)` and a commutative diagram. We should be able to read the commutative diagram as `inj âšˆx = â—‹x` again. Now verify it!

*However, still, can we derive this `var*` definition from internal programming in glued topos?*


***

Now that we have `var* : {ğ’° | Â¶ â†ª tm}`, we can construct `var(-)` using realignment.

`var'(X) = {x : var* | Â¶ â†ª x.tp = X}`
However, `Â¶ â‡’ var'(X) = {âˆ‘(A : tp) tm(A)| A = X}` only isomorphic to `tm(X)`

We need to use realignment to achieve that 
`var(X) :  {ğ’° | Â¶ â†ª tm(X)}`


## Replay 5.5.3âˆ—3, but in STLC

It should be simpler, because now `tm(A)` and `Var(A)` are both real object/presheaf since `A` can standalone.

## Extensional Property/Usage for `var(A)`

Another problem is that, we construct `var(A)` intensionally, but what is the extensional property it has? What/Where it is used for intensionally defined in this way? Why Â§5.5.3âˆ—3 emphasizes represetnable natural transformation?

For exmaple, `ne` is defined directly on `var`. But it doesn't seem to use any `var` property thus why do we need `var` to be defined in this way?

## The structure of Adequacy 

We need to spit out the adequacy result. This part is commeting (JS2, Sec 5.6).


First, recall https://ncatlab.org/nlab/show/Artin+gluing#some_details_and_further_adjunctions 
provides specifics for open/close immersion

### (5.6.1âˆ—1) 
using `i_!` as part of the definition of atomic substitution simply because (5.6.1âˆ—3) 

### (5.6.1âˆ—4) 

claims, following 5.6.1âˆ—4 itself

Î±! : Setğ´ â†’ Setğ‘‡ âŠ£ Î±* : Setğ‘‡ 

j*(i!(yA(Î“))) = j*(Î±!(yA(Î“)), ...) = Î±!(yA(Î“)) â‰… yT(Î±(Î“)) (Î±! is yoneda extension of Î±)

```
Hom (yA(Î”), Î±*j*(| Î“ |))
â‰… Hom (Î±_! yA(Î”), j*(| Î“ |) )
â‰… Hom (yT(Î±(Î”)), yT(Î±(Î“)))
â‰… Hom(Î±(Î”), Î±(Î“))
```

### (5.6.2âˆ—4) 

**We have computability structure of a canonical point**

Canonical points are form of `âŸ¦Î“âŸ§ â†’ X`.


So a `Hom_Setğº(âŸ¦-âŸ§, X) : Setğ´` turn into a computability structure by : 
1. by (5.6.2âˆ—4) we have an arrow `f : Hom_Setğº(âŸ¦-âŸ§, X) â†’ Î±*j*X` in `Setğ´`
2. an object in `Setğº` is a triple `(_â‚ : Setğ‘‡, _â‚‚ : Setğ´, _â‚‚ â†’ Î±*(_â‚) : Setğ´)`.

3. So the turned computability is 
`(j*X, Hom_Setğº(âŸ¦-âŸ§, X), f) `


So given `X`, we have `X_can := (j*X, Hom_Setğº(âŸ¦-âŸ§, X), f) `

**We have computability structure of a atomic point**

Atomic points are form of `(| Î“ |) â†’ X`.


By (5.6.1âˆ—3), `iso : i*X â‰… Hom_Setğº((| - |), X)`

So given `X`, we have `X = (j*X, i*X, X_f) â‰… (j*X, Hom_Setğº((| - |), X), iso âˆ˜ X_f)`

A bit confusion comes from, is `X_f` one to one correspondes ` Hom_Setğº((| - |), X) â†’ Î±*j*X`?

I guess so because every `X_f` uniquely corresponds to `X`, which uniquely corresponds to `X â†’ j_*j*X`,
but we need a proof

Conjecture : every `X_f` is uniquely corresponding to the ` Hom_Setğº((| - |), X) â†’ Î±*j*X` in 5.6.2âˆ—4

## 5.6.2âˆ—3

Why it can be pattern matching like that?

## 5.6.2âˆ—6


`M(T) â†’ M#(T)_can` is `Î±*yT(T) â†’ Hom_Setğº(âŸ¦-âŸ§,M#T)` simply because

```
M(T) = j_* (yT(T)) = (yT(T), Î±*yT(T), id)
```
So this commutative diagram is enough to specify this function

***

## Questions about adequacy
1. Why this adequacy is so complicated compared to STC-Canonicity proof? 

*** 
Then we can rearrange the above proof into our current STLC-NbE proof.

# Syntax

Syntax in STC is written in HOAS, as before

```agda 
record STLC : Set where 
  ty : â–¡
  tm : ty â†’ â–¡
  bool : ty 
  true :  tm bool
  false : tm bool
  arr : ty â†’ ty â†’ ty
  lam : (tm A â†’ tm B) â†’ tm (arr A B)
  app : tm (arr A B) â†’ tm A â†’ tm B
  lamÎ² : app (lam f) = f
  lamÎ· : lam (app f) = f 
```

Like STC for Canonicity, we write

***

The ğ’œ mentioned in 5.5.1âˆ—7 is actually just category of renaming.
The interesting part is that the original syntax Pr(ğ’¯) is pretty HOAS, so when translate a variable `Î“ âŠ¢ ? : A`, it becomes 
`Î“* â†’ A* : ğ’¯`

So just like Coquand, we are still gluing with `Pr(ğ’œ)`.

Interestingly, in Coquand, Nf, Ne, Var are all dependent presheaf arised from judgement. However, here our 

# Question : How is nf, ne defined?



# Question : What is the var?

