---
layout: post
title:  "Review JS's STC's NbE'"
date:   2023-11-03 00:56:11 -0400
categories: Type-Theory Cat-Theory
---

We type-set JS's STC and its application on proving NbE of STLC

Ref:
(JS1) https://www.jonmsterling.com/papers/sterling-2022-naive.pdf

(JS2) https://www.cs.cmu.edu/~rwh/students/sterling.pdf

(JS3) https://arxiv.org/abs/1809.08646


# What is open term here?

我之前有个巨大的错误理解 -- 我以为Sterling把tm = `∑ (A : tp), tm(A)` 之后，NbE也是在closed term上的（毕竟syntax里面都没有context了。。）。
但其实他应该是在用
α(Γ) → tm 来表达open term了，然后才会有atomic & canonical point（我读了好久都不知道这两个玩意是干啥用的笑死）


# General Proof Structure of Synthetic Normalization


This is a summary of proof structure in (JS2, Chapter 5)

1. Still we use the same syntax.

2. Then we glue a topos based on renaming/atomic category 𝐴, and then do a glue (5.5.1∗7) via the figure shape α : 𝐴 → 𝑇.


3. Then we explore the existence of `var(A)` (JS2,5.5.3∗3) **The hardest! Have no idea**

4. Then we define normal, neutral form in the closed subspace of the glued topos (Section 5.4.1)

5. Finally we construct Synthetic Logical Relation 


## 5.5.3∗3

在Presheaf Cat里面，我能不能如下方式定义一个representable natural transformation?
根据


## 5.5.3∗3, But Intensionally


Notice in § 5.5, the 𝒜 category is exactly the category of renaming, so this section is a categorical reformulation of 
Coquand's normalization paper.

Sure, we need to construct `var : (X : tp) → {𝒰 | ¶ ↪ tm(X)}`
and thus we have 
`var(X) = [¶ ↪ x : tm(X) | ?]`

we definitely know `?` should be a proposition indicating `x` should be a pure variable. Inspect our toolset, we don't have enough tools to specify that internally. 

Let's jump out externally, but the first problem is, what is `x : tm(A)` externally speaking. In STLC we can say that is something like `Hom(1, tm(A))` but not in dependnet type. To make `tm(A)` a 
real object, we have to close the free variable `tm = ∑ (A : tp) tm(A)`

Now we know the `var* : {𝒰 | ¶ ↪ tm}` indicating all kinds of variables.
`var* = [ ¶ ↪ x : tm | ? ]`

`?` should be a proof that `x` is a variable (of all kinds of types). 

Can we construct this proof internally?

***
However, 
Review § 5.5,
we can construct `V : Pr(𝒜)`, where `V(Γ) = { (T, x) | T : Ty(Γ), x is variable of type T in Γ }`. Intensionally, `V` should corresponds to `tm` directly, and we have `inj : V → α*(y(tm))` (we will omit y later)

Then we consider the object `var* = (tm, V, inj → α*(tm))`.
As most objects in Glued topos/Logical Relation are pairs, and have two components, one for syntax, the other for the meta-level reasoning. So this pair, directly read it,
intuitively, `x : (tm, V, inj : V → α*(tm))` should give us a variable in `Pr(𝒯)` and its corresponding form in `x' : V : Pr(𝒜)`, where `inj` should be the proof that `inj x' = x`. 

We prove that:
1. Consider arbitrary `x : Hom(1, var*)`, it has two morphism 
`○x : Hom_𝒯(1, tm)` and `⚈x : Hom_𝒜(1, V)` and a commutative diagram. We should be able to read the commutative diagram as `inj ⚈x = ○x`. Now verify it!
2. Consider arbitrary `x : Hom(?, var*)` for arbitrary context `Γ : 𝒜`, it has two morphism 
`○x : Hom_𝒯(?, tm)` and `⚈x : Hom_𝒜(y(Γ), V)` and a commutative diagram. We should be able to read the commutative diagram as `inj ⚈x = ○x` again. Now verify it!

*However, still, can we derive this `var*` definition from internal programming in glued topos?*


***

Now that we have `var* : {𝒰 | ¶ ↪ tm}`, we can construct `var(-)` using realignment.

`var'(X) = {x : var* | ¶ ↪ x.tp = X}`
However, `¶ ⇒ var'(X) = {∑(A : tp) tm(A)| A = X}` only isomorphic to `tm(X)`

We need to use realignment to achieve that 
`var(X) :  {𝒰 | ¶ ↪ tm(X)}`


## Replay 5.5.3∗3, but in STLC

It should be simpler, because now `tm(A)` and `Var(A)` are both real object/presheaf since `A` can standalone.

## Extensional Property/Usage for `var(A)`

Another problem is that, we construct `var(A)` intensionally, but what is the extensional property it has? What/Where it is used for intensionally defined in this way? Why §5.5.3∗3 emphasizes represetnable natural transformation?

For exmaple, `ne` is defined directly on `var`. But it doesn't seem to use any `var` property thus why do we need `var` to be defined in this way?

## The structure of Adequacy 

We need to spit out the adequacy result. This part is commeting (JS2, Sec 5.6).


First, recall https://ncatlab.org/nlab/show/Artin+gluing#some_details_and_further_adjunctions 
provides specifics for open/close immersion

### (5.6.1∗1) 
using `i_!` as part of the definition of atomic substitution simply because (5.6.1∗3) 

### (5.6.1∗4) 

claims, following 5.6.1∗4 itself

α! : Set𝐴 → Set𝑇 ⊣ α* : Set𝑇 

j*(i!(yA(Γ))) = j*(α!(yA(Γ)), ...) = α!(yA(Γ)) ≅ yT(α(Γ)) (α! is yoneda extension of α)

```
Hom (yA(Δ), α*j*(| Γ |))
≅ Hom (α_! yA(Δ), j*(| Γ |) )
≅ Hom (yT(α(Δ)), yT(α(Γ)))
≅ Hom(α(Δ), α(Γ))
```

### (5.6.2∗4) 

**We have computability structure of a canonical point**

Canonical points are form of `⟦Γ⟧ → X`.


So a `Hom_Set𝐺(⟦-⟧, X) : Set𝐴` turn into a computability structure by : 
1. by (5.6.2∗4) we have an arrow `f : Hom_Set𝐺(⟦-⟧, X) → α*j*X` in `Set𝐴`
2. an object in `Set𝐺` is a triple `(_₁ : Set𝑇, _₂ : Set𝐴, _₂ → α*(_₁) : Set𝐴)`.

3. So the turned computability is 
`(j*X, Hom_Set𝐺(⟦-⟧, X), f) `


So given `X`, we have `X_can := (j*X, Hom_Set𝐺(⟦-⟧, X), f) `

**We have computability structure of a atomic point**

Atomic points are form of `(| Γ |) → X`.


By (5.6.1∗3), `iso : i*X ≅ Hom_Set𝐺((| - |), X)`

So given `X`, we have `X = (j*X, i*X, X_f) ≅ (j*X, Hom_Set𝐺((| - |), X), iso ∘ X_f)`

A bit confusion comes from, is `X_f` one to one correspondes ` Hom_Set𝐺((| - |), X) → α*j*X`?

I guess so because every `X_f` uniquely corresponds to `X`, which uniquely corresponds to `X → j_*j*X`,
but we need a proof

Conjecture : every `X_f` is uniquely corresponding to the ` Hom_Set𝐺((| - |), X) → α*j*X` in 5.6.2∗4

## 5.6.2∗3

Why it can be pattern matching like that?

## 5.6.2∗6


`M(T) → M#(T)_can` is `α*yT(T) → Hom_Set𝐺(⟦-⟧,M#T)` simply because

```
M(T) = j_* (yT(T)) = (yT(T), α*yT(T), id)
```
So this commutative diagram is enough to specify this function

***

## Questions about adequacy
1. Why this adequacy is so complicated compared to STC-Canonicity proof? 

*** 
Then we can rearrange the above proof into our current STLC-NbE proof.

# Syntax

Syntax in STC is written in HOAS, as before

```agda 
record STLC : Set where 
  ty : □
  tm : ty → □
  bool : ty 
  true :  tm bool
  false : tm bool
  arr : ty → ty → ty
  lam : (tm A → tm B) → tm (arr A B)
  app : tm (arr A B) → tm A → tm B
  lamβ : app (lam f) = f
  lamη : lam (app f) = f 
```

Like STC for Canonicity, we write

***

The 𝒜 mentioned in 5.5.1∗7 is actually just category of renaming.
The interesting part is that the original syntax Pr(𝒯) is pretty HOAS, so when translate a variable `Γ ⊢ ? : A`, it becomes 
`Γ* → A* : 𝒯`

So just like Coquand, we are still gluing with `Pr(𝒜)`.

Interestingly, in Coquand, Nf, Ne, Var are all dependent presheaf arised from judgement. However, here our 

# Question : How is nf, ne defined?



# Question : What is the var?

