---
layout: post
title:  "Review JS's STC's NbE'"
date:   2023-11-03 00:56:11 -0400
categories: Type-Theory Cat-Theory
---

We type-set JS's STC and its application on proving NbE of STLC

Ref:
(JS1) https://www.jonmsterling.com/papers/sterling-2022-naive.pdf

(JS2) https://www.cs.cmu.edu/~rwh/students/sterling.pdf

(JS3) https://arxiv.org/abs/1809.08646



# General Proof Structure

This is a summary of proof structure in (JS2, Chapter 5)

1. Still we use the same syntax.

2. Then we glue a topos based on renaming/atomic category ğ´, and then do a glue (5.5.1âˆ—7) via the figure shape Î± : ğ´ â†’ ğ‘‡.


3. Then we explore the existence of `var(A)` (JS2,5.5.3âˆ—3) **The hardest! Have no idea**

4. Then we define normal, neutral form in the closed subspace of the glued topos (Section 5.4.1)

5. Finally we construct Synthetic Logical Relation 


## 5.5.3âˆ—3



## The structure of Adequacy 

We need to spit out the adequacy result. This part is commeting (JS2, Sec 5.6).


First, recall https://ncatlab.org/nlab/show/Artin+gluing#some_details_and_further_adjunctions 
provides specifics for open/close immersion

### (5.6.1âˆ—1) 
using `i_!` as part of the definition of atomic substitution simply because (5.6.1âˆ—3) 

### (5.6.1âˆ—4) 

claims, following 5.6.1âˆ—4 itself

Î±! : Setğ´ â†’ Setğ‘‡ âŠ£ Î±* : Setğ‘‡ 

j*(i!(yA(Î“))) = j*(Î±!(yA(Î“)), ...) = Î±!(yA(Î“)) â‰… yT(Î±(Î“)) (Î±! is yoneda extension of Î±)

```
Hom (yA(Î”), Î±*j*(| Î“ |))
â‰… Hom (Î±_! yA(Î”), j*(| Î“ |) )
â‰… Hom (yT(Î±(Î”)), yT(Î±(Î“)))
â‰… Hom(Î±(Î”), Î±(Î“))
```

### (5.6.2âˆ—4) 

**We have computability structure of a canonical point**

Canonical points are form of `âŸ¦Î“âŸ§ â†’ X`.


So a `Hom_Setğº(âŸ¦-âŸ§, X) : Setğ´` turn into a computability structure by : 
1. by (5.6.2âˆ—4) we have an arrow `f : Hom_Setğº(âŸ¦-âŸ§, X) â†’ Î±*j*X` in `Setğ´`
2. an object in `Setğº` is a triple `(_â‚ : Setğ‘‡, _â‚‚ : Setğ´, _â‚‚ â†’ Î±*(_â‚) : Setğ´)`.

3. So the turned computability is 
`(j*X, Hom_Setğº(âŸ¦-âŸ§, X), f) `


So given `X`, we have `X_can := (j*X, Hom_Setğº(âŸ¦-âŸ§, X), f) `

**We have computability structure of a atomic point**

Atomic points are form of `(| Î“ |) â†’ X`.


By (5.6.1âˆ—3), `iso : i*X â‰… Hom_Setğº((| - |), X)`

So given `X`, we have `X = (j*X, i*X, X_f) â‰… (j*X, Hom_Setğº((| - |), X), iso âˆ˜ X_f)`

A bit confusion comes from, is `X_f` one to one correspondes ` Hom_Setğº((| - |), X) â†’ Î±*j*X`?

I guess so because every `X_f` uniquely corresponds to `X`, which uniquely corresponds to `X â†’ j_*j*X`,
but we need a proof

Conjecture : every `X_f` is uniquely corresponding to the ` Hom_Setğº((| - |), X) â†’ Î±*j*X` in 5.6.2âˆ—4

## 5.6.2âˆ—3

Why it can be pattern matching like that?

## 5.6.2âˆ—6


`M(T) â†’ M#(T)_can` is `Î±*yT(T) â†’ Hom_Setğº(âŸ¦-âŸ§,M#T)` simply because

```
M(T) = j_* (yT(T)) = (yT(T), Î±*yT(T), id)
```
So this commutative diagram is enough to specify this function

***

## Questions about adequacy
1. Why this adequacy is so complicated compared to STC-Canonicity proof? 

*** 
Then we can rearrange the above proof into our current STLC-NbE proof.

# Syntax

Syntax in STC is written in HOAS, as before

```agda 
record STLC : Set where 
  ty : â–¡
  tm : ty â†’ â–¡
  bool : ty 
  true :  tm bool
  false : tm bool
  arr : ty â†’ ty â†’ ty
  lam : (tm A â†’ tm B) â†’ tm (arr A B)
  app : tm (arr A B) â†’ tm A â†’ tm B
  lamÎ² : app (lam f) = f
  lamÎ· : lam (app f) = f 
```

Like STC for Canonicity, we write

