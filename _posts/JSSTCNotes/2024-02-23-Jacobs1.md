Ref 
1. Jacobs
***
Terminology :

## Morphism between Fibration/ Fibred Functor : Definition 1.7.1, or https://ncatlab.org/nlab/show/fibred+functor 

Basically functor preserves cartesian morphism.

## Simple Fibration
Given `T âŠ† ğ”¹â‚€`,
`s(T)` objects : (Î“ âˆˆ ğ”¹, X âˆˆ T) 
morphisms : (Î“, X) â†’ (Î”, Y) is
  u : Î“ â†’ Î” and f : Î“ Ã— X â†’ Y

## Fibred Functor preserves product/coproduct : Definition 1.9.13
For `p : ğ”¼ â†’ ğ”¹, q : ğ”» â†’ ğ”¸`, `H := (K, L) : p â†’ q` is a fibred functor, i.e. `K : ğ”¹ â†’ ğ”¸`

Basically, because fibred functor `H := (K, L) : p â†’ q` preserves cartesian morphism, 

so we have
` K âˆ˜ p = q âˆ˜ L`, this commutation/equation alone is enough 
to make sure `K` always map fibred category to fibred category.

So we can consider `H` as a functor, for each `I âˆˆ ğ”¹` between fibred category `ğ”¼_I â†’ ğ”»_(K I)`.
Now that `H` is a functor between fibred category, this makes it possible to talk about preserve simple products, 
but apparently we need `K(I Ã— J) â‰… K I Ã— K J` on the base category.

## What Preserve Simple Product

Currently we have reindexed functor, and fibred functor preserve simple product (fibrewise).
The former one is called Beck-Chevalley condition, to make product compatible with substitution, Definition 1.9.1.

## Fibrewise Construction is not mentioned in Chapter 2
Weird.

***




# Lemma 1.7.6
1. by K : (ğ”¸, S) â†’ (ğ”¹, T), we automatically have the commutation in fibred functor.
2. Because K preserves product (not necessary on the nose), so we have `Î³ : K (A) Ã— K (B) â‰… K(A Ã— B)`
3. each cartesian lifting in simple fibration for `u âˆˆ ğ”¸â‚`, is exactly `(u, Ï€)`
4. the challenge is to use Î³ to make a fibered functor to preserve split on the nose.

# Lemma 2.4.7
<!-- We can understand this lemma is sort of about internal language -->


