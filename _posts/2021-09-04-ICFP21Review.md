---
layout: post
title:  "ICFP21 - Review I - 导引 I"
date:   2021-09-04 00:56:11 -0400
categories: CS Type-Theory
---

This blog post will be written in English/Mandarin.

既然被导师要求写点review, 不如挪到知乎这里来。

This blog post is not really reviewing anything, but it suffices as a supplementary material for specific topics.

这则博客不是真的在点评，而是以几篇paper作为中心进行背景补充。

***

# PLMW talk : Mechanizing Metatheory
By [Brigitte Pientka](https://www.cs.mcgill.ca/~bpientka/) 

可惜了，youtube version 最后没被上传。就凑合着看吧。

Mechanizing Metatheory usually refers to the action that formalize the meta-theory in a proof assistant.

个人无法翻译 Mechanizing Metatheory。这一般是指用 [定理证明器](https://en.wikipedia.org/wiki/Proof_assistant) 形式化某个元理论。

## Motivation 动机

元理论是指讨论关于一个理论本身的性质。比如说我们想证明*所有通过Java类型检查和证明的程序不会出现运行时的Null Exception*这样一个定理，（[曾经是错的现在不知道怎么样了](https://dl.acm.org/doi/10.1145/2983990.2984004)），这样的定理是讨论Java类型系统本身的，所以被称作元定理。

一般来说这样的定理是用纸笔/Latex做做证明的。但是从Proof Engineering的角度来看，这样在Latex上的定义、定理没什么扩展性，而且细节容易掉进犄角旮旯里而导致某些错漏，加之没有定理证明怎么能相信你的证明呢（（

Metatheory is about reasoning about the theory itself. For example, if we want to prove an miniKanren implementation can solve all the propositional logic query (in some level of time complexity) or we want to prove any query on propositional logic will halt in miniKanren and return a complete non-duplicated set of solution; or we want to prove a compiled (typed) Java program will never raise an exception. This kind of reasoning about miniKanren/Java Programming Language itself is an example of metatheory.


Usually this kind of proving is done in latex and paper, but it is hard to keep track of all the details in the paper, and it is not scalable (when you want to alter the definition) -- so using proof assistant to let machine check this kind of proof is becoming a prevalent choice.



## Challenge 现有问题 

然而，使用定理证明器需要大量的训练和经验。最简单的例子：元理论中，在论文里面你可以省略对于变量操作（例如变量替换，自由变量提取）的细节。然而对电脑来说，这类操作必须严谨完整的写出来；而且这些操作本身会有一些trivial的性质。比如说 $$X[a \mapsto c][b \mapsto  d] = X[b \mapsto  d] [a \mapsto c]$$ *亦即在某些简单的情况下可以交换替换顺序* 这个定理就要被完整的在定理证明器中递推的证明一遍。只是考虑这些变量就耗费大量的精力去证明相关的Lemma。

仅仅考虑变量本身，在定理证明器中就有[多种设计模式](https://www.seas.upenn.edu/~plclub/poplmark/)可以[参考](https://poplmark-reloaded.github.io/)。然而 Pientka 主要是考虑 [HOAS](http://adam.chlipala.net/cpdt/html/Cpdt.ProgLang.html) ([Higher-order Abstract Syntax](https://en.wikipedia.org/wiki/Higher-order_abstract_syntax)) 和 [Contextual Modal Type Theory](https://dl.acm.org/doi/10.1145/1352582.1352591)。

However, using proof assistant requires a lot of training and experience. For example, usually in the paper you can assume the reader has the idea of variable, and variable substitution (substitute all variable occurences with something else), and this kind of boilerplate definition need to be explicitly defined in a proof assistant. And what's more, some trivial lemma X[a -> c][b -> d] = X[b->d][a->c] (i.e. substitution on a and substitution on b are independent of their order) needs to explicitly proved by the user using proof assistant/cannot easily generate this kind of proof. Just reasoning variable binding in an example can be highly nontrivial and requires a lot of labor.



To achieve this kind of reasoning, there have been multiple proposed ways of handling variables themselves on proving all kinds of meta-theorem. But Pientka is mainly working on HOAS (Higher-order abstract syntax) and contextual modal type theory.


### HOAS

简单来说, HOAS是一个*用于 将 程序本身 表达成 数据结构* 的 设计模式。比如说我们用简单的代数数据类型/BNF 表达一个程序 `tm := var | Lam var tm | App tm tm` 。这里的`Lam`还是用一个简单的tuple表达的。现在我们考虑写一个*替换*函数，可以想象这个函数不断的递归分解每个子结构。然后我们会需要 [capture-avoiding substitution](https://stackoverflow.com/questions/11239262/what-is-meant-by-capture-avoiding-substitutions), 亦即考虑同名变量的shadowing问题。

然而如果我们用HOAS的话， 这个Lam就会直接存一个函数本身 `fun var => tm`， 亦即这次我们用一个函数作为数据结构的一部分。这就是*Higher-order*的意思。

这样看的话，好处是 -- *替换*函数做 capture-avoiding substitution 会简单一点 ([alpha-renaming](https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence))，直接把传入这个函数一个term即可 ； 坏处是 -- 我们有一个函数作为数据的一部分，解构这个数据本身有点复杂，尤其是在定理证明器中使用HOAS的时候（这里可能有点争议，可能参考Pientka的演讲和[CPDT](http://adam.chlipala.net/cpdt/html/Cpdt.ProgLang.html)会更好）。

然而在定理证明器中使用HOAS不是那么容易，因为定理证明器有[Strict Positivity](https://cs.stackexchange.com/questions/55646/strict-positivity)的限制。去解决这个问题，我们有很多种办法。Pientka研究的就是使用Contextual Type Theory解决这个问题的同时，combine the best between [LF](https://en.wikipedia.org/wiki/Logical_framework) and [MLTT](https://en.wikipedia.org/wiki/Intuitionistic_type_theory#Martin-L%C3%B6f_type_theories). 去更细致的讨论需要不少的LF + MLTT基础。

HOAS is a technique to represent program. For example, if we use data structure to represent program, we will have BNF definition `tm := var | Lam var tm | App tm tm` Look at how lambda is represented as a  pair of variable and term. (a data structure again) Consider how (capture-avoiding) substitution will need to inspect/destruct this data structure recursively. Using HOAS, we use function of the program itself to represent a lambda term instead of using a var and a data representing lambda term.


In that way, we gain something -- substitution is just applying this stored function inside data structure! But we lose something -- functions are not really (algebraic) data type so we cannot inspect/destruct it easily.


There are a lot of ways to handle this challenge in the context of proof assistant.
Contextual type theory is an attempt to do that -- we can use better representation for variable binding; and we can inspect the data as well.  And there are a lot of ongoing work around it, and the theory and tool is not mature compared to the Coq/Agda community.
And there are more details in the talk, but require some basic knowledges on LF/dependent type/type theory.


